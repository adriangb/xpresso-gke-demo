import random
from datetime import datetime
from typing import Annotated, Literal

from httpx import AsyncClient, Response
from pydantic import BaseModel, Field

from app.db.repositories.articles import ArticlesRepository
from tests.integration.conftest import RegistedUserWithToken


async def test_publish_article(
    test_client: AsyncClient,
    registered_users_with_tokens: list[RegistedUserWithToken],
) -> None:
    author = random.choice(registered_users_with_tokens)

    payload = {
        "article": {
            "title": "How to train your dragon",
            "description": "Ever wonder how?",
            "body": "It takes a Jacobian",
            "tagList": ["dragons", "training"],
        }
    }

    # to avoid fudging with datetimes, we use a Pydantic
    # model to verify that we get the values we expect
    # or in the case of UUIDs/datetimes generated by the database
    # that they are of the right types

    class ResponseProfileValidator(BaseModel):
        username: Annotated[str, Field(const=True)] = author.user.username
        bio: Annotated[str | None, Field(const=True)] = author.user.bio
        image: Annotated[str | None, Field(const=True)] = author.user.image
        following: Annotated[bool, Field(const=True)] = False

    class ResponseArticleValidator(BaseModel):
        slug: str
        title: Literal["How to train your dragon"]
        description: Literal["Ever wonder how?"]
        body: Literal["It takes a Jacobian"]
        tagList: Annotated[list[str], Field(const=True)] = ["dragons", "training"]
        createdAt: datetime
        updatedAt: datetime
        favorited: Literal[False]
        favoritesCount: Literal[0]
        author: ResponseProfileValidator

    class ReponseValidator(BaseModel):
        article: ResponseArticleValidator

    resp: Response = await test_client.post(
        f"/api/articles",
        headers={"Authorization": f"Token {author.token}"},
        json=payload,
    )
    assert resp.status_code == 200, resp.content
    ReponseValidator.validate(resp.json())


async def test_list_articles(
    test_client: AsyncClient,
    registered_users_with_tokens: list[RegistedUserWithToken],
) -> None:
    await test_publish_article(test_client, registered_users_with_tokens)
    resp: Response = await test_client.get(
        "/api/articles",
    )
    assert resp.status_code == 200, resp.content
    print(resp.json())
