from datetime import datetime
from typing import Annotated, Literal, Type

import pytest
from httpx import AsyncClient, Response
from pydantic import BaseModel, Field

from app.db.repositories.articles import ArticlesRepository
from app.db.repositories.users import UsersRepository
from tests.integration.conftest import RegistedUserWithToken
from tests.integration.fixtures.repos import REGISTERED_USERS_INFO


@pytest.fixture
def author(
    registered_users_with_tokens: list[RegistedUserWithToken],
) -> RegistedUserWithToken:
    return registered_users_with_tokens[0]


@pytest.fixture
def article_validation_model(author: RegistedUserWithToken) -> Type[BaseModel]:
    # to avoid fudging with datetimes, we use a Pydantic
    # model to verify that we get the values we expect
    # or in the case of UUIDs/datetimes generated by the database
    # that they are of the right types

    class ResponseProfileValidator(BaseModel):
        username: Annotated[str, Field(const=True)] = author.user.username
        bio: Annotated[str | None, Field(const=True)] = author.user.bio
        image: Annotated[str | None, Field(const=True)] = author.user.image
        following: Annotated[bool, Field(const=True)] = False

    class ResponseArticleValidator(BaseModel):
        slug: str
        title: Literal["How to train your dragon"]
        description: Literal["Ever wonder how?"]
        body: Literal["It takes a Jacobian"]
        tagList: Annotated[list[str], Field(const=True)] = ["dragons", "training"]
        createdAt: datetime
        updatedAt: datetime
        favorited: Literal[False]
        favoritesCount: Literal[0]
        author: ResponseProfileValidator

    return ResponseArticleValidator


async def test_publish_article(
    test_client: AsyncClient,
    article_validation_model: Type[BaseModel],
    author: RegistedUserWithToken,
) -> None:
    payload = {
        "article": {
            "title": "How to train your dragon",
            "description": "Ever wonder how?",
            "body": "It takes a Jacobian",
            "tagList": ["dragons", "training"],
        }
    }

    resp: Response = await test_client.post(
        "/api/articles",
        headers={"Authorization": f"Token {author.token}"},
        json=payload,
    )
    assert resp.status_code == 201, resp.content
    article_validation_model.validate(resp.json()["article"])


async def test_list_articles(
    test_client: AsyncClient,
    author: RegistedUserWithToken,
    article_validation_model: Type[BaseModel],
    articles_repo: ArticlesRepository,
) -> None:
    """Test the shape of the data returned by GET /articles"""
    await articles_repo.create_article(
        author_id=author.id,
        title="How to train your dragon",
        description="Ever wonder how?",
        body="It takes a Jacobian",
        tags=["dragons", "training"],
    )
    resp: Response = await test_client.get(
        "/api/articles",
        headers={"Authorization": f"Token {author.token}"},
    )
    assert resp.status_code == 200, resp.content
    for article in resp.json()["articles"]:
        article_validation_model.validate(article)


@pytest.mark.parametrize(
    "params,expected_titles",
    [
        # by tags
        ({}, ["3", "2", "1"]),
        ({"tag": "tag1"}, ["1"]),
        ({"tag": "tag2"}, ["2", "1"]),
        # by author
        ({"author": REGISTERED_USERS_INFO[0].username}, ["2", "1"]),
        ({"author": REGISTERED_USERS_INFO[1].username}, ["3"]),
        ({"author": REGISTERED_USERS_INFO[2].username}, []),
        # by favorited
        ({"favorited": REGISTERED_USERS_INFO[0].username}, ["3"]),
        ({"favorited": REGISTERED_USERS_INFO[1].username}, ["2"]),
        ({"favorited": REGISTERED_USERS_INFO[2].username}, ["3", "1"]),
    ],
)
async def test_list_articles_filter(
    params: dict[str, str],
    expected_titles: list[str],
    test_client: AsyncClient,
    registered_users_with_tokens: list[RegistedUserWithToken],
    articles_repo: ArticlesRepository,
) -> None:
    # create a couple of articles
    article_1 = await articles_repo.create_article(
        author_id=registered_users_with_tokens[0].id,
        title="1",
        description="",
        body="",
        tags=["tag1", "tag2"],
    )
    article_2 = await articles_repo.create_article(
        author_id=registered_users_with_tokens[0].id,
        title="2",
        description="",
        body="",
        tags=["tag2", "tag3"],
    )
    article_3 = await articles_repo.create_article(
        author_id=registered_users_with_tokens[1].id,
        title="3",
        description="",
        body="",
        tags=["tag4"],
    )
    # and some likes on them
    await articles_repo.favorite_article(
        current_user_id=registered_users_with_tokens[0].id,
        article_id=article_3.id,
    )
    await articles_repo.favorite_article(
        current_user_id=registered_users_with_tokens[1].id,
        article_id=article_2.id,
    )
    await articles_repo.favorite_article(
        current_user_id=registered_users_with_tokens[2].id,
        article_id=article_1.id,
    )
    await articles_repo.favorite_article(
        current_user_id=registered_users_with_tokens[2].id,
        article_id=article_3.id,
    )

    resp: Response = await test_client.get(
        "/api/articles",
        headers={"Authorization": f"Token {registered_users_with_tokens[2].token}"},
        params=params,
    )
    assert resp.status_code == 200, resp.content
    assert [art["title"] for art in resp.json()["articles"]] == expected_titles


@pytest.mark.parametrize(
    "current_user_idx,expected_titles",
    [
        (0, []),
        (1, ["2", "1"]),
        (2, ["3", "2", "1"]),
    ],
)
async def test_articles_feed(
    current_user_idx: int,
    expected_titles: list[str],
    test_client: AsyncClient,
    registered_users_with_tokens: list[RegistedUserWithToken],
    articles_repo: ArticlesRepository,
    users_repo: UsersRepository,
) -> None:
    # follow users
    await users_repo.follow_user(
        username_to_follow=registered_users_with_tokens[0].user.username,
        id_of_current_user=registered_users_with_tokens[1].id,
    )
    await users_repo.follow_user(
        username_to_follow=registered_users_with_tokens[0].user.username,
        id_of_current_user=registered_users_with_tokens[2].id,
    )
    await users_repo.follow_user(
        username_to_follow=registered_users_with_tokens[1].user.username,
        id_of_current_user=registered_users_with_tokens[2].id,
    )
    # create a couple of articles
    await articles_repo.create_article(
        author_id=registered_users_with_tokens[0].id,
        title="1",
        description="",
        body="",
        tags=["tag1", "tag2"],
    )
    await articles_repo.create_article(
        author_id=registered_users_with_tokens[0].id,
        title="2",
        description="",
        body="",
        tags=["tag2", "tag3"],
    )
    await articles_repo.create_article(
        author_id=registered_users_with_tokens[1].id,
        title="3",
        description="",
        body="",
        tags=["tag4"],
    )

    resp: Response = await test_client.get(
        "/api/articles/feed",
        headers={
            "Authorization": f"Token {registered_users_with_tokens[current_user_idx].token}"
        },
    )
    assert resp.status_code == 200, resp.content
    assert [art["title"] for art in resp.json()["articles"]] == expected_titles


async def test_delete_article(
    test_client: AsyncClient,
    author: RegistedUserWithToken,
    articles_repo: ArticlesRepository,
) -> None:
    article = await articles_repo.create_article(
        author_id=author.id,
        title="How to train your dragon",
        description="Ever wonder how?",
        body="It takes a Jacobian",
        tags=["dragons", "training"],
    )
    resp: Response
    resp = await test_client.delete(
        f"/api/articles/{article.id}",
        headers={"Authorization": f"Token {author.token}"},
    )
    assert resp.status_code == 204, resp.content

    resp = await test_client.get("/api/articles")
    assert resp.status_code == 200, resp.content
    assert resp.json() == {"articles": []}


async def test_update_article(
    test_client: AsyncClient,
    author: RegistedUserWithToken,
    articles_repo: ArticlesRepository,
) -> None:
    article = await articles_repo.create_article(
        author_id=author.id,
        title="How to train your dragon",
        description="Ever wonder how?",
        body="It takes a Jacobian",
        tags=["dragons", "training"],
    )
    payload = {
        "article": {
            "title": "New Title",
            "description": "New description",
            "body": "New body!",
        }
    }
    resp: Response
    resp = await test_client.put(
        f"/api/articles/{article.id}",
        headers={"Authorization": f"Token {author.token}"},
        json=payload,
    )
    assert resp.status_code == 200, resp.content

    resp = await test_client.get(f"/api/articles/{article.id}")
    assert resp.status_code == 200, resp.content
    received_article = resp.json()["article"]
    assert received_article["title"] == "New Title"
    assert received_article["description"] == "New description"
    assert received_article["body"] == "New body!"


async def test_favorite_article(
    test_client: AsyncClient,
    registered_users_with_tokens: list[RegistedUserWithToken],
    articles_repo: ArticlesRepository,
) -> None:
    # create an article
    article = await articles_repo.create_article(
        author_id=registered_users_with_tokens[0].id,
        title="1",
        description="",
        body="",
        tags=["tag1", "tag2"],
    )

    resp: Response
    resp = await test_client.post(
        f"/api/articles/{article.id}/favorite",
        headers={"Authorization": f"Token {registered_users_with_tokens[1].token}"},
    )
    assert resp.status_code == 200, resp.content
    assert resp.json()["article"]["favorited"] is True


async def test_unfavorite_article(
    test_client: AsyncClient,
    registered_users_with_tokens: list[RegistedUserWithToken],
    articles_repo: ArticlesRepository,
) -> None:
    current_user = registered_users_with_tokens[1]
    # create an article
    article = await articles_repo.create_article(
        author_id=registered_users_with_tokens[0].id,
        title="1",
        description="",
        body="",
        tags=["tag1", "tag2"],
    )
    await articles_repo.favorite_article(
        current_user_id=current_user.id,
        article_id=article.id,
    )

    resp: Response
    resp = await test_client.delete(
        f"/api/articles/{article.id}/favorite",
        headers={"Authorization": f"Token {current_user.token}"},
    )
    assert resp.status_code == 200, resp.content
    assert resp.json()["article"]["favorited"] is False
