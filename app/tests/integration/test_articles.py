from datetime import datetime
from typing import Annotated, Literal, Type

import pytest
from httpx import AsyncClient, Response
from pydantic import BaseModel, Field

from app.db.repositories.articles import ArticlesRepository
from tests.integration.conftest import RegistedUserWithToken
from tests.integration.fixtures.repos import REGISTERED_USERS_INFO


@pytest.fixture
def author(
    registered_users_with_tokens: list[RegistedUserWithToken],
) -> RegistedUserWithToken:
    return registered_users_with_tokens[0]


@pytest.fixture
def article_validation_model(author: RegistedUserWithToken) -> Type[BaseModel]:
    # to avoid fudging with datetimes, we use a Pydantic
    # model to verify that we get the values we expect
    # or in the case of UUIDs/datetimes generated by the database
    # that they are of the right types

    class ResponseProfileValidator(BaseModel):
        username: Annotated[str, Field(const=True)] = author.user.username
        bio: Annotated[str | None, Field(const=True)] = author.user.bio
        image: Annotated[str | None, Field(const=True)] = author.user.image
        following: Annotated[bool, Field(const=True)] = False

    class ResponseArticleValidator(BaseModel):
        slug: str
        title: Literal["How to train your dragon"]
        description: Literal["Ever wonder how?"]
        body: Literal["It takes a Jacobian"]
        tagList: Annotated[list[str], Field(const=True)] = ["dragons", "training"]
        createdAt: datetime
        updatedAt: datetime
        favorited: Literal[False]
        favoritesCount: Literal[0]
        author: ResponseProfileValidator

    class ReponseValidator(BaseModel):
        article: ResponseArticleValidator

    return ReponseValidator


async def test_publish_article(
    test_client: AsyncClient,
    article_validation_model: Type[BaseModel],
    author: RegistedUserWithToken,
) -> None:
    payload = {
        "article": {
            "title": "How to train your dragon",
            "description": "Ever wonder how?",
            "body": "It takes a Jacobian",
            "tagList": ["dragons", "training"],
        }
    }

    resp: Response = await test_client.post(
        "/api/articles",
        headers={"Authorization": f"Token {author.token}"},
        json=payload,
    )
    assert resp.status_code == 200, resp.content
    article_validation_model.validate(resp.json())


async def test_list_articles(
    test_client: AsyncClient,
    author: RegistedUserWithToken,
    article_validation_model: Type[BaseModel],
    articles_repo: ArticlesRepository,
) -> None:
    """Test the shape of the data returned by GET /articles"""
    await articles_repo.create_article(
        author_id=author.id,
        title="How to train your dragon",
        description="Ever wonder how?",
        body="It takes a Jacobian",
        tags=["dragons", "training"],
    )
    resp: Response = await test_client.get(
        "/api/articles",
        headers={"Authorization": f"Token {author.token}"},
    )
    assert resp.status_code == 200, resp.content
    for article in resp.json():
        article_validation_model.validate(article)


@pytest.mark.parametrize(
    "params,expected_titles",
    [
        # by tags
        ({}, ["1", "2", "3"]),
        ({"tag": "tag1"}, ["1"]),
        ({"tag": "tag2"}, ["1", "2"]),
        # by author
        ({"author": REGISTERED_USERS_INFO[0].username}, ["1", "2"]),
        ({"author": REGISTERED_USERS_INFO[1].username}, ["3"]),
        ({"author": REGISTERED_USERS_INFO[2].username}, []),
    ],
)
async def test_list_articles_filter(
    params: dict[str, str],
    expected_titles: list[str],
    test_client: AsyncClient,
    registered_users_with_tokens: list[RegistedUserWithToken],
    article_validation_model: Type[BaseModel],
    articles_repo: ArticlesRepository,
) -> None:
    await articles_repo.create_article(
        author_id=registered_users_with_tokens[0].id,
        title="1",
        description="",
        body="",
        tags=["tag1", "tag2"],
    )
    await articles_repo.create_article(
        author_id=registered_users_with_tokens[0].id,
        title="2",
        description="",
        body="",
        tags=["tag2", "tag3"],
    )
    await articles_repo.create_article(
        author_id=registered_users_with_tokens[1].id,
        title="3",
        description="",
        body="",
        tags=["tag4"],
    )

    resp: Response = await test_client.get(
        "/api/articles",
        headers={"Authorization": f"Token {registered_users_with_tokens[2].token}"},
        params=params,
    )
    assert resp.status_code == 200, resp.content
    assert [res["article"]["title"] for res in resp.json()] == expected_titles
